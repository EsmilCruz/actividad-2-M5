<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Acvidad</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <header class="header">
        <center>
            <h1>Actividad</h1>
        </center>
        <hr>
    </header>

    <main class="contenido">
        <h2>1. Estructuras de Datos</h2>
            
        <h3>Arrays (Arreglos)</h3>
        <p><strong>Definición y características:</strong> Un array es una estructura de datos que almacena una colección de elementos del mismo tipo en posiciones de memoria contiguas. El tamaño del array es fijo y los elementos se acceden mediante un índice numérico.</p>
        <ul>
            <li>Acceso rápido a elementos por índice.</li>
            <li>Inserción y eliminación pueden ser costosas en términos de tiempo.</li>
        </ul>

        <h4>Operaciones básicas:</h4>
        <ul>
            <li><strong>Acceso:</strong> Acceder a un elemento usando su índice.</li>
            <li><strong>Inserción:</strong> Mover elementos para hacer espacio para uno nuevo.</li>
            <li><strong>Eliminación:</strong> Mover elementos para llenar el espacio vacío.</li>
        </ul>

        <h4>Arrays multidimensionales:</h4>
        <p>Un array multidimensional es un array de arrays, como una tabla o matriz, usado para almacenar datos en formato tabular.</p>

        <h3>Listas Enlazadas</h3>
        <p><strong>Listas enlazadas simples:</strong> Secuencia de nodos donde cada nodo apunta al siguiente.</p>
        <p><strong>Listas doblemente enlazadas:</strong> Cada nodo tiene referencias al nodo anterior y siguiente.</p>
        <p><strong>Listas circularmente enlazadas:</strong> El último nodo apunta al primero, formando un ciclo.</p>

        <h4>Operaciones básicas:</h4>
        <ul>
            <li><strong>Inserción:</strong> Ajustar referencias de los nodos para insertar un nuevo nodo.</li>
            <li><strong>Eliminación:</strong> Ajustar referencias para remover un nodo.</li>
            <li><strong>Búsqueda:</strong> Recorrer nodos para encontrar el dato deseado.</li>
        </ul>

        <h3>Pilas (Stacks)</h3>
        <p><strong>Principio LIFO:</strong> Last In, First Out. La última entrada es la primera en salir.</p>
        
        <h4>Operaciones:</h4>
        <ul>
            <li><strong>Push:</strong> Inserta un elemento en la parte superior.</li>
            <li><strong>Pop:</strong> Elimina y devuelve el elemento superior.</li>
            <li><strong>Peek:</strong> Devuelve el elemento superior sin eliminarlo.</li>
        </ul>
    </section>

    <section>
        <h2>2. Algoritmos</h2>
        
        <h3>Algoritmos de Ordenación</h3>
        <ul>
            <li>Bubble Sort</li>
            <li>Insertion Sort</li>
            <li>Selection Sort</li>
            <li>Quick Sort</li>
            <li>Merge Sort</li>
            <li>Heap Sort</li>
        </ul>

        <h3>Algoritmos de Búsqueda</h3>
        <ul>
            <li>Linear Search</li>
            <li>Binary Search</li>
            <li>DFS en grafos</li>
            <li>BFS en grafos</li>
        </ul>

        <h3>Algoritmos de Programación Dinámica</h3>
        <p><strong>Concepto:</strong> Resuelve problemas complejos dividiéndolos en subproblemas y almacenando sus soluciones para evitar cálculos redundantes.</p>

        <h4>Problemas clásicos:</h4>
        <ul>
            <li>Mochila</li>
            <li>Secuencia de Fibonacci</li>
            <li>Cadena de matrices</li>
        </ul>
        
        <h3>Complejidad Computacional</h3>
        <p><strong>Notación Big O:</strong> Representa el comportamiento asintótico del tiempo de ejecución de un algoritmo.</p>
        
        <h4>Análisis de tiempo y espacio:</h4>
        <ul>
            <li><strong>Tiempo:</strong> Mide el tiempo de ejecución en función del tamaño de la entrada.</li>
            <li><strong>Espacio:</strong> Mide la cantidad de memoria requerida.</li>
        </ul>

        <h3>Casos promedio, mejor y peor caso:</h3>
        <ul>
            <li><strong>Mejor caso:</strong> La complejidad mínima del algoritmo.</li>
            <li><strong>Peor caso:</strong> La complejidad máxima que el algoritmo puede alcanzar.</li>
            <li><strong>Caso promedio:</strong> El comportamiento esperado del algoritmo en una entrada aleatoria.</li>
        </ul>

        <h2>Técnicas de Optimización</h2>
        <ul>
            <li><strong>Estrategias para mejorar la eficiencia:</strong> Incluye técnicas como eliminar operaciones redundantes, mejorar el acceso a la memoria, paralelización, y uso de estructuras de datos eficientes.</li>
            <li><strong>Técnicas de poda:</strong>
                <ul>
                    <li><strong>Poda alfa-beta en juegos:</strong> Una técnica de optimización en algoritmos de búsqueda de árboles de decisión que reduce el número de nodos evaluados en un árbol de juego, manteniendo la misma decisión óptima.</li>
                </ul>
            </li>
        </ul>
        </section>
    </main>

    <footer class="pie">
        <h4> Nos reservamos todos los derechos &copy; Esmil Cruz</h4>
    </footer>
    
</body>
</html>